# lkjagent - プログラム仕様書

## 概要

lkjagentは、小規模な言語学習モデル（LLM）向けに設計された自律型AIエージェントフレームワークです。自動的なデータ編成、ツール実行機能、継続的な自律動作を備えた高度なメモリ管理システムを提供します。エージェントはBツリーのようなメモリ構造で動作し、ワーキングメモリと永続ストレージの両方を効率的に管理できます。

## コアアーキテクチャ

### 1. エージェントループシステム

主な実行フローは `agent_loop.ts` モジュールによって調整され、継続的な操作サイクルを実装します。

- **初期化**: LLM接続をテストし、設定を検証します。
- **反復ループ**: 以下のステップで無期限に実行されます。
  1. 現在のメモリコンテキストでシステムプロンプトを生成します。
  2. 構造化されたプロンプトでLLMを呼び出します。
  3. LLM応答からXML形式のアクションを解析します。
  4. セキュリティおよびフォーマットルールに対してアクションを検証します。
  5. 検証されたアクションをメモリ/ストレージ上で実行します。
  6. 結果をログに記録し、次の反復に進みます。
- **エラー処理**: 設定可能なリトライ遅延により、エラーから適切に回復します。
- **シャットダウン**: SIGINTを処理して正常に終了します。

### 2. メモリ管理システム

#### ワーキングメモリ構造
```
/working_memory/
├── user_data/          # ユーザー固有のデータとタスク
│   └── todo/           # タスク管理
├── action_result/      # 実行結果 (自動クリーンアップ)
│   └── _N/            # 番号付き結果エントリ
└── system_info/        # システム状態情報
```

#### ストレージ構造
```
/storage/               # 永続ストレージ (プロンプトには含まれない)
└── [any_path]/         # 階層的データストレージ
```

#### メモリ特性
- **ワーキングメモリ**: `working_memory_character_max` によって制限されます (デフォルト: 2048文字)。
- **ストレージ**: 無制限の永続ストレージで、LLMプロンプトからは除外されます。
- **自動クリーンアップ**: アクション結果は処理後に自動的に削除されます。
- **Bツリー構造**: データは効率的なアクセスのために階層的に整理されます。

### 3. ツールシステム

#### 利用可能なツール

1. **set** - 指定されたパスにデータを保存します。
   - ターゲット: `/working_memory/` または `/storage/` パス
   - コンテンツ: JSONシリアライズ可能な任意のデータ
   - 中間パスを自動的に作成します。

2. **get** - 指定されたパスからデータを取得します。
   - パスにあるデータを返すか、見つからない場合はエラーを返します。
   - メモリパスとストレージパスの両方で動作します。

3. **rm** - 指定されたパスのデータを削除します。
   - ファイル/ディレクトリを再帰的に削除します。
   - パスパーミッションを検証します。

4. **mv** - パス間でデータを移動/名前変更します。
   - ソースパスとターゲットパスが必要です。
   - メモリ/ストレージ間の移動をサポートします。

5. **ls** - ディレクトリパスの内容を一覧表示します。
   - ディレクトリ構造を表示します。
   - ファイルエントリかディレクトリエントリかを示します。

6. **search** - クエリベースのコンテンツ検索。
   - 指定されたスコープパス内で検索します。
   - 一致するエントリをコンテンツプレビューと共に返します。

7. **mkdir** - ディレクトリ構造を作成します。
   - 必要に応じて親ディレクトリを作成します。
   - べき等操作です。

#### ツール検証ルール
- すべてのパスは `/working_memory/` または `/storage/` で始まる必要があります。
- 必須パラメータは実行前に検証されます。
- パストラバーサル攻撃を防止します。
- 複雑なデータに対するJSONコンテンツ検証。

### 4. LLM連携

#### 通信プロトコル
- **APIフォーマット**: OpenAI互換のチャット補完API
- **デフォルトエンドポイント**: `http://localhost:1234/v1/chat/completions`
- **リクエストフォーマット**: 完全なコンテキストを含むシステムメッセージ付きのJSON
- **レスポンスフォーマット**: XML構造化されたアクションコマンド

#### LLM設定
```typescript
interface LLMConfig {
  llm_api_url: string;      // APIエンドポイントURL
  llm_model: string;        // モデル識別子
  llm_max_tokens: number;   // 応答長制限
  llm_temperature: number;  // 創造性パラメータ (0.0-1.0)
}
```

#### 応答フォーマット仕様
LLMは、以下の厳密なフォーマットでXML応答を返す必要があります。
```xml
<actions>
  <action>
    <kind>set|get|rm|mv|ls|search|mkdir</kind>
    <target_path>/working_memory/パス または /storage/パス</target_path>
    <source_path>ソースパス (mv専用)</source_path>
    <content>データコンテンツ (set専用)</content>
  </action>
  <!-- 追加のアクション -->
</actions>
```

### 5. 設定システム

#### 設定ファイル: `data/config.json`

```typescript
interface AppConfig {
  // メモリ管理
  working_memory_character_max: number;    // メモリサイズ制限 (デフォルト: 2048)
  key_token_max?: number;                  // キー長制限 (デフォルト: 4)
  working_memory_children_max?: number;    // 最大子オブジェクト数 (デフォルト: 8)

  // LLM設定
  llm_api_url?: string;                    // LLMエンドポイント
  llm_model?: string;                      // モデル名
  llm_max_tokens?: number;                 // 応答トークン制限
  llm_temperature?: number;                // サンプリング温度

  // システム設定
  system_max_log_entries?: number;         // ログ保持制限
  system_auto_cleanup?: boolean;           // 古い結果の自動削除
  system_debug_mode: boolean;              // デバッグ出力制御
}
```

#### データファイル構造
```
data/
├── config.json         # アプリケーション設定
├── memory.json          # ワーキングメモリ永続化
├── storage.json         # ストレージデータ永続化
└── log.json            # アクション実行ログ
```

### 6. プロンプトエンジニアリング

#### システムプロンプト構造
エージェントは以下を含む包括的なシステムプロンプトを受け取ります。

1. **現在のメモリ状態**: XMLとしての完全なワーキングメモリ
2. **ペルソナ定義**: 「自律的に思考する最も強力なAI」としての役割
3. **行動仕様**:
   - Bツリーのような構造で情報を管理する
   - ワーキングメモリを容量制限まで満たす
   - 制限に近づいたら重要度の低いデータをストレージに退避させる
   - タスクがない場合は創造的なコンテンツを生成する
   - TODOとnext_actionを継続的に更新する
   - 全てのアクション結果を参照用に保存する
4. **出力フォーマットルール**: 厳格なXML応答フォーマット要件

#### 自律的行動ガイドライン
- **メモリ最適化**: メモリ効率を自動的に管理する
- **タスク管理**: TODOリストを維持・更新する
- **クリエイティブモード**: アイドル時にファンタジー小説を生成する
- **自己指示**: 次のアクションを自律的に決定する
- **結果保存**: 学習のためにすべてのアクションをログに記録する

### 7. データ永続化

#### ファイルフォーマット: JSON
すべてのデータは、人間が読みやすくデバッグしやすいJSON形式で保存されます。

#### 永続化戦略
- **即時書き込み**: 変更は実行後すぐに保存されます。
- **アトミック操作**: ファイル書き込みは破損を防ぐためにアトミックです。
- **バックアップ戦略**: 以前のバージョンは手動で保存できます。
- **リカバリ**: 破損したデータファイルを適切に処理します。

#### メモリ vs ストレージ
- **メモリ**: すべてのLLMプロンプトに含まれ、サイズ制限があります。
- **ストレージ**: プロンプトから除外され、サイズは無制限です。
- **移行**: エージェントは必要に応じてメモリとストレージ間でデータを移動できます。

### 8. エラー処理と検証

#### 検証レイヤー
1. **スキーマ検証**: アクション構造の準拠性
2. **パス検証**: セキュリティとフォーマットチェック
3. **コンテンツ検証**: データ型とサイズ制限
4. **実行検証**: ランタイムエラー処理

#### エラー回復
- **エラー時継続**:致命的でないエラーは実行を停止しません。
- **エラーログ記録**: すべてのエラーがコンテキストと共にログに記録されます。
- **リトライロジック**: 指数バックオフによる自動リトライ。
- **グレースフルデグラデーション**: 部分的な機能が維持されます。

### 9. セキュリティに関する考慮事項

#### パスセキュリティ
- **ホワイトリスト方式**: `/working_memory/` と `/storage/` のみが許可されます。
- **パストラバーサル防止**: `../` シーケンスはブロックされます。
- **サンドボックス強制**: システムファイルへのアクセスはありません。

#### コンテンツセキュリティ
- **JSON検証**: すべてのコンテンツは有効なJSONである必要があります。
- **サイズ制限**: 設定可能な制限によりメモリ枯渇を防ぎます。
- **型安全性**: TypeScriptによる全体的な型強制。

### 10. テストフレームワーク

#### テストカテゴリ
1. **単体テスト**: 個々のツール機能
2. **統合テスト**: 完全なワークフローテスト
3. **包括的テスト**: 全ツールのシーケンステスト
4. **パフォーマンステスト**: メモリと速度のベンチマーク

#### テストカバレッジ
- 成功/失敗ケースを含む全7種類のツール
- メモリ管理のエッジケース
- LLM通信エラーシナリオ
- 設定検証

### 11. 開発とデプロイメント

#### ビルドプロセス
```bash
npm run build      # TypeScriptをJavaScriptにコンパイル
npm run start      # コンパイル済みエージェントを実行
npm run dev        # ウォッチ付き開発モード
npm run test       # 全テストを実行
```

#### 依存関係
- **ランタイム**: Node.js, TypeScript, axios, fs-extra
- **開発**: TypeScriptサポートのための@typesパッケージ
- **外部**: LLMサーバー (LMStudio, Ollamaなど)

#### ディレクトリ構造
```
lkjagent/
├── src/                 # TypeScriptソースコード
│   ├── index.ts         # メインエントリポイント
│   ├── config/          # 設定管理
│   ├── tool/            # ツール実装
│   ├── types/           # TypeScriptインターフェース
│   └── util/            # ユーティリティ関数
├── data/                # ランタイムデータファイル
├── dist/                # コンパイル済みJavaScript
├── test-*.js            # テストスイート
└── package.json         # プロジェクト設定
```

### 12. 運用特性

#### スケーラビリティ
- **単一インスタンス**: 単一エージェント操作用に設計
- **ステートフル**: 再起動後も永続的な状態を維持
- **拡張可能**: 新しいツールをモジュール式に追加可能

#### モニタリング
- **コンソールログ**: 詳細な操作ログ
- **デバッグモード**: 追加の診断情報
- **アクショントラッキング**: 全操作の完全な監査証跡

## 利用パターン

### 初期化
1. 依存関係のインストール: `npm install`
2. データファイルの初期化: `npm run init-data`
3. `data/config.json` でLLMエンドポイントを設定
4. 設定されたエンドポイントでLLMサーバーを起動
5. エージェントの起動: `npm start`

### 標準的な操作フロー
1. エージェントが起動し、LLM接続をテストします。
2. 現在のメモリ状態をプロンプトにロードします。
3. LLMがコンテキストを受け取り、アクションで応答します。
4. アクションが解析、検証、実行されます。
5. 結果がaction_resultに保存され、メモリが更新されます。
6. プロセスが無期限に繰り返されます。

### カスタマイズポイント
- **ツール拡張**: `src/tool/` に新しいツールを追加
- **プロンプト変更**: `src/util/prompt.ts` で動作をカスタマイズ
- **メモリ構造**: データ編成パターンを変更
- **LLM連携**: 異なるAPIフォーマットに対応

この包括的な仕様書は、lkjagentシステムの完全な再構築のための基盤を提供し、すべての必須機能、アーキテクチャ上の決定、および運用特性を網羅しています。