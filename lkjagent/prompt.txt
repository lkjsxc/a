Hello, Copilot. You will be implementing an AI agent project called `lkjagent` in TypeScript, based on the provided README. The goal is to faithfully reproduce the specifications in the README and generate high-quality, maintainable code.

**Project Overview:**
`lkjagent` is a local AI agent with minimal essential features. It aims to operate with small language models (around 8b parameters). Memory is stored in JSON format and converted to a markup language (XML) when communicating with the agent.

**Overall Instructions:**
*   **Language:** TypeScript
*   **Style:** Please write clear, readable code, emphasize modularity, maximize type safety, and include appropriate comments.
*   **Error Handling:** Please consider basic error handling.
*   **File Structure:** Please generate files according to the following structure described in the README.

```
lkjagent/
├── README.md  (This is provided)
├── docs/
│   └── readme_jp.md (This is provided)
└── src/
    ├── index.ts
    ├── memory.json
    ├── storage.json
    ├── tool/
    │   ├── ram_set.ts
    │   ├── ram_remove.ts
    │   ├── storage_get.ts
    │   ├── storage_remove.ts
    │   ├── storage_search.ts
    │   └── storage_set.ts
    └── types/
        └── common.ts
```

**Implementation Steps:**

Please implement each file according to the following steps.

**Step 1: Type Definitions (`src/types/common.ts`)**

*   Based on the `<lkjagent_system_setup>` XML structure in the README, especially the `<memory_architecture>` (RAM, Storage), `<tool>` examples, and `<output_format_specification>`, please define the types to be used throughout the project.
*   Consider the following as main types (but not limited to these):
    *   `MemoryState`: A type representing the structure of `memory.json` (including RAM contents).
    *   `StorageState`: A type representing the structure of `storage.json` (including Storage contents).
    *   `RamData`: A type reflecting the structure of the `<ram>` section in the README (e.g., `current_task`, `thinking_log`, `todo`, tool examples).
    *   `StorageData`: A type reflecting the structure of the `<storage>` section in the README (e.g., `knowledge_base`, `archived_data`).
    *   `TodoItem`: A type for each task in the `todo` list.
    *   `ToolAction`: A type for actions the agent executes (refer to the `<output_format_specification>` and `<tool>` examples in the README, with properties like `kind`, `path`, `content`).
    *   Types for tool function arguments and return values.
*   Be mindful of the relationship between JSON data structures and the XML elements used for communication with the LLM.

**Step 2: Initial State of Memory and Storage (`src/memory.json`, `src/storage.json`)**

*   Based on the initial states of the `<ram>` and `<storage>` sections within `<lkjagent_system_setup>` in the README, please generate the `memory.json` and `storage.json` files.
*   These JSON files should conform to the `MemoryState` and `StorageState` types (or similar types) defined in `src/types/common.ts`.

**Step 3: Tool Set (`src/tool/` directory files)**

*   Please implement each of the following tool files in TypeScript. Each tool should be exported as an independent function and be usable from `index.ts`.
*   Use the types defined in `common.ts` for arguments and return values.
*   These tools will primarily manipulate data in `memory.json` and `storage.json`. Refer to the `<memory_architecture>` in the README for the data structures to be manipulated.
    *   **`ram_set.ts`**:
        *   Feature: Adds or updates new data at a specified path in RAM (e.g., `ram.todo.new_task`).
        *   Arguments: `path` (string), `content` (any/appropriate type).
        *   Operation: Modifies data in `memory.json`.
    *   **`ram_remove.ts`**:
        *   Feature: Deletes data at a specified path in RAM.
        *   Arguments: `path` (string).
        *   Operation: Modifies data in `memory.json`.
    *   **`storage_get.ts`**:
        *   Feature: Loads data from a specified path in Storage and places it in a temporary area in RAM (e.g., `ram.loaded_data`), or returns the data directly.
        *   Arguments: `path` (string).
        *   Operation: Reads data from `storage.json`. Updates `memory.json` if necessary.
    *   **`storage_remove.ts`**:
        *   Feature: Deletes data at a specified path in Storage.
        *   Arguments: `path` (string).
        *   Operation: Modifies data in `storage.json`.
    *   **`storage_search.ts`**:
        *   Feature: Searches data in Storage by keyword. Refer to the README example (`<content>fn provide_offset</content>`) for the search target and method, and ensure flexibility (e.g., recursively search values within JSON).
        *   Arguments: `content` (string/search query).
        *   Return Value: Search results (e.g., a list of path-value pairs).
        *   Operation: Searches data in `storage.json`.
    *   **`storage_set.ts`**:
        *   Feature: Saves data from a specified path in RAM to a specified path in Storage. The README example shows behavior like saving `ram.db.schema` to an assumed `storage.db.schema`.
        *   Arguments: `source_path` (string, path in RAM), `destination_path` (string, path in Storage).
        *   Operation: Reads data from `memory.json` and writes to `storage.json`.

**Step 4: Main Entry Point (`src/index.ts`)**

*   Implement the main logic of the agent. This will manage the agent's operational cycle.
*   The main features are as follows:
    1.  **Initialization:**
        *   Load `memory.json` and `storage.json` from the file system and make them available in the program as objects of type `MemoryState` and `StorageState`. Use the `fs` module (e.g., `fs.readFileSync`, `JSON.parse`).
    2.  **System Prompt Construction:**
        *   Use the `<lkjagent_system_setup>` XML structure described in the README as a template.
        *   Implement a function that dynamically inserts the current contents of `MemoryState` (RAM) and `StorageState` (Storage) into the `<ram>...</ram>` and `<storage>...</storage>` sections of this XML template to generate the complete input prompt string (in XML format) for the LLM.
        *   **Note:** Logic is required to convert JSON objects to XML strings. Since the XML structure is simple, you can consider manually constructing the string or using a lightweight XML library (e.g., `xml-js` or parts of `fast-xml-parser`). Feel free to use suggestions from Copilot if available.
    3.  **LLM Integration (Stub):**
        *   Implement this part as a stub function that simulates actual LLM API calls.
        *   This stub function should take the generated system prompt string and return an XML string specifying the agent's actions (in a format similar to the `<output_format_specification>` example in the README).
        *   Example: `async function callLLM(prompt: string): Promise<string> { /* ... */ return "<action><kind>add</kind>...</action>"; }`
        *   Anticipating future replacement with an actual LLM API (e.g., HTTP requests to a local LLM server), please add a comment: `// TODO: Implement LLM call`.
    4.  **Action Parsing and Execution:**
        *   Implement a function to parse the XML-formatted action list returned from the LLM.
        *   Based on each parsed `<action>` (of type `ToolAction`), call the corresponding tool function implemented in Step 3 (dispatch using the `kind` property).
        *   **Note:** Logic is required to parse the XML string into an object array like `ToolAction[]`. Again, consider using a simple XML parser here.
    5.  **State Update:**
        *   Update the state of memory (`MemoryState`) and storage (`StorageState`) according to the execution results of the tool functions.
        *   Write the updated state back to `memory.json` and `storage.json` periodically or at the end of the agent's processing cycle (e.g., using `fs.writeFileSync`, `JSON.stringify`).
    6.  **Main Loop / Execution Flow:**
        *   Following the `<initial_instruction>` in the README, implement the flow where the agent starts up and processes the initial task (`setup_001`).
        *   Implement a basic operational loop that allows the agent to process tasks based on the `todo` list, interact with the LLM, and update its state.
        *   First, assume the LLM will generate specific actions to process the `setup_001` task, and focus on implementing the flow up to executing those actions.

**Points to Pay Special Attention To:**

*   **RAM and Storage Data Structures:** Faithfully reproduce the structure defined in the README's `<memory_architecture>`. For parts marked "to be written later," use your judgment to decide if the current definition is sufficient or if extensions are needed to achieve a high-quality implementation.
*   **JSON to XML and XML to JSON Conversion:** These conversions are necessary during prompt construction and LLM response parsing in `index.ts`. Choose appropriate methods.
*   **Asynchronous Operations:** Use asynchronous operations (async/await) appropriately for file I/O and LLM calls (including stubs).
*   **Error Handling and Logging:** Consider potential errors in each feature and add basic error handling (e.g., try-catch) and simple logging for debugging (e.g., `console.log`, `console.error`) as needed.

**Deliverables:**

*   All TypeScript files (`.ts`) and JSON files (`.json`) according to the file structure above.
*   Each file should contain appropriate comments explaining the processing and TypeScript type definitions.
*   `index.ts` should be the entry point that can start the basic execution flow of the agent.

If you have any unclear points or are unsure about any decisions during the process, please ask questions as needed. I expect code that will form the foundation of a high-quality AI agent.

Now, please begin the implementation!
It's recommended to start with `src/types/common.ts`. Next, create `src/memory.json` and `src/storage.json`, then implement the tools in `src/tool/`, and finally `src/index.ts`.

---